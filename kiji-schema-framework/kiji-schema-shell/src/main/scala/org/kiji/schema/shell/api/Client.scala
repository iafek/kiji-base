/**
 * (c) Copyright 2013 WibiData, Inc.
 *
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.kiji.schema.shell.api

import java.io.ByteArrayOutputStream
import java.io.Closeable
import java.io.InputStream
import java.io.PrintStream

import org.kiji.annotations.ApiAudience
import org.kiji.annotations.ApiStability
import org.kiji.schema.KConstants
import org.kiji.schema.KijiURI
import org.kiji.schema.shell.AbstractKijiSystem
import org.kiji.schema.shell.Environment
import org.kiji.schema.shell.InputProcessor
import org.kiji.schema.shell.KijiSystem
import org.kiji.schema.shell.ddl.DDLCommand
import org.kiji.schema.shell.ddl.ErrorCommand
import org.kiji.schema.shell.input.InputSource
import org.kiji.schema.shell.input.StreamInputSource
import org.kiji.schema.shell.input.StringInputSource
import org.kiji.schema.util.ResourceUtils

/**
 * An API used to programmatically execute Schema DDL commands.
 *
 * <p>Create a new instance of a Client, parameterized by a Kiji URI,
 * using the `Client.newInstance(uri)` method.</p>
 *
 * <p>Make one or more calls to `executeStream()` and `executeUpdate()`.
 * Instances of this class are not internally synchronized and should be restricted to
 * a single client thread.</p>
 *
 * <p>Call the `close()` method when you are done with this to release system resources.</p>
 *
 * <p>A client is bound to a particular Kiji URI when it is created. Client instances
 * appear stateless between calls to one of the execute*() methods. So for instance, a
 * `USE` statement in `executeUpdate()` would not cause any specific effect.
 * You should create a client for the specific Kiji instance you want to connect to.
 * A `USE` statement or other environment-altering statement within a stream being
 * processed via `executeStream()` will have an effect on the remainder of the stream,
 * but is not persistent between streams.</p>
 */
@ApiAudience.Public
@ApiStability.Experimental
final class Client private(val kijiUri: KijiURI, val kijiSystem: AbstractKijiSystem)
    extends Closeable {

  /** Output stream where stdout from DDL commands is redirected. */
  private val mStdoutBytes = new ByteArrayOutputStream

  /** Last environment returned by the input processor. */
  private var mLastEnv: Option[Environment] = None

  /**
   * Executes a DDL statement. The statement does not need to be terminated by a ';'
   * character.
   *
   * @param ddl the DDL statement to execute. (e.g., "CREATE TABLE ...")
   * @throws DDLException if there's an error processing the command.
   */
  def executeUpdate(ddl: String): Unit = {
    val trimmed = ddl.trim()
    val trueScript = if (trimmed.endsWith(";")) { trimmed } else { trimmed + ";" }
    doExecute(new StringInputSource(trueScript))
  }

  /**
   * Executes a set of DDL statements in a file or other stream-based resource.
   *
   * <p>Processes a stream line-wise as if it is a script file containing one or more
   * DDL input statements. Statements must be terminated by a ';' character. The stream
   * will be entirely consumed and also closed by this method.</p>
   *
   * @param stream is an InputStream containing one or more DDL statements to execute.
   *     (e.g., "CREATE TABLE ...")
   * @throws DDLException if there's an error processing the command.
   */
  def executeStream(stream: InputStream): Unit = {
    doExecute(new StreamInputSource(stream))
  }

  /**
   * Actually execute DDL statements from executeUpdate() or executeStream().
   *
   * @param input the InputSource to read from.
   * @throws DDLException if there's an error processing the command.
   */
  private def doExecute(input: InputSource): Unit = {
    mStdoutBytes.reset()
    val output = new PrintStream(mStdoutBytes, false, "UTF-8")
    try {
      val env = (mLastEnv match {
        case Some(last) => last.withPrinter(output).withInputSource(input)
        case None => new Environment(kijiUri, output, kijiSystem, input, List(), false)
      })
      mLastEnv = Some(new InputProcessor(throwOnErr=true)
          .processUserInput(new StringBuilder(), env))
    } finally {
      ResourceUtils.closeOrLog(output)
      ResourceUtils.closeOrLog(input)
    }
  }

  /**
   * Returns any console output generated by the last statement executed. Multiple
   * calls to executeUpdate(), etc will overwrite this data.
   *
   * @return the 'stdout' text associated with the most recent call to executeUpdate()
   */
  def getLastOutput(): String = {
    return mStdoutBytes.toString("UTF-8")
  }

  /**
   * Close resources used by the DDL system. This method must be called
   * when you are done with the client.
   */
  def close(): Unit = {
    kijiSystem.shutdown()
  }
}

object Client {
  /**
   * Create a new instance of a Client object.
   * <p>Java programs should call Client.newInstance(uri).</p>
   *
   * @param uri the Kiji URI to connect to. This must specify a Kiji instance, not an
   *     HBase cluster URI. (e.g., `kiji://.env/myinstance`.)
   * @return a new instance of a Client object.
   */
  def newInstance(uri: KijiURI): Client = {
    return new Client(uri, new KijiSystem)
  }

  /**
   * Create a new instance of a Client object.
   *
   * package-private method for internal testing use, allowing the user to override the
   * KijiSystem implementation used. End-users should not try to pass a non-default argument
   * for the KijiSystem implementation and should use `newInstance` instead.
   *
   * @param uri the Kiji URI to connect to. This must specify a Kiji instance, not an
   *     HBase cluster URI. (e.g., `kiji://.env/myinstance`.)
   * @param sys the AbstractKijiSystem implementation to use.
   * @return a new instance of a Client object.
   */
  private[shell] def newInstanceWithSystem(uri: KijiURI, sys: AbstractKijiSystem): Client = {
    return new Client(uri, sys)
  }
}
